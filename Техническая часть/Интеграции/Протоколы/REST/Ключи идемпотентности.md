**Ключ идемпотентности** — это уникальное значение, которое создаётся на стороне клиента и отправляется на сервер вместе с запросом. Ключ является инструментом для идентификации и контроля за повторными запросами. Для него рекомендуется использовать формат UUID. Когда клиент желает повторить запрос, он отправляет новый, включая тот же ключ идемпотентности:![[hczheodzyndyregzzzcd1rlqr64.png]]

Вопрос о том, где следует контролировать идемпотентность, становится важным на этапе разработки. Хотя добавление логики контроля в контроллер может показаться простым решением, оно не является оптимальным. Вместо этого предпочтительнее внедрить блок контроля идемпотентности между клиентом и контроллером с бизнес логикой, на уровне инфраструктуры. Такой подход обладает несколькими преимуществами:
1) Снижение зависимости от изменений в бизнес-логике контроллера. Это означает, что изменения в бизнес-логике не повлияют на механизм идемпотентности, что обеспечивает более гибкую и устойчивую систему
2) Унификация логики обработки для всех запросов. Это упрощает поддержку и обеспечивает единый стандарт в системе

**Обработка нового запроса**

При поступлении нового запроса с уникальным ключом идемпотентности необходимо осуществить обработку, состоящую из следующих шагов:
1) Новый запрос с уникальным ключом идемпотентности требует сохранения соответствующей информации в хранилище данных. Это позволяет отслеживать состояние запроса и его уникальный ключ
2) Для предотвращения возможных конфликтов блокировка устанавливается на этапе обработки запроса. Она гарантирует, что операции будут выполнены последовательно и предотвращает параллельную обработку запросов с одним ключом идемпотентности
3) Исполнение бизнес-логики контроллера
4) По завершении исполнения запроса блок отвечает за сохранение ответа в хранилище данных. Это позволяет клиенту получить тот же результат при повторном запросе
5) После сохранения ответа, блок освобождает блокировку, позволяя другим запросам с тем же ключом идемпотентности продолжить своё выполнение

**Повторная обработка запроса**

Обработка повторного запроса, состоит из следующих этапов:
1) Блок контроля идемпотентности проверяет наличие ключа из текущего запроса в хранилище данных
2) Если ключ уже имеется в хранилище и связан с сохранённым ответом, то блок возвращает этот ответ, обозначая успешное завершение запроса
3) Дальнейшая обработка запроса и выполнение бизнес-логики контроллера не происходят, поскольку запрос уже успешно обработан

**Обработка запроса при активной блокировке**

Одной из ключевых задач блока контроля идемпотентности является предотвращение параллельного исполнения конфликтующих запросов с использованием одного ключа. Для этого важно устанавливать блокировку на время обработки запроса. Одним из вариантов обработки запроса с заблокированным ключом является возврат ошибки с кодом 409 Conflict. Для улучшения клиентского опыта, помимо ошибки 409 Conflict можно также возвращать информацию о времени, через которое клиенту стоит повторить запрос. Это делается с помощью заголовка Retry-After. Когда мы возвращаем его, мы переносим ответственность за повтор запроса на сторону клиента. Но можно использовать более гибкий подход к обработке запросов с заблокированным ключом, оставив часть ответственности на стороне сервера. Получив запрос с заблокированным ключом идемпотентности, включается режим ожидания. Через определённый период мы проверяем, завершил ли текущий обладатель блокировки выполнение запроса. Если ответ уже готов, то мы направляем его клиенту, создавая впечатление успешного выполнения бизнес-логики запроса. При этом предотвращаем повторное исполнение, гарантируя идемпотентность. В случае отсутствия готового ответа после ожидания, мы можем также вернуть ошибку 409 Conflict, сообщая клиенту о невозможности повторного выполнения запроса в настоящий момент. Такой гибкий и невидимый для клиента подход обеспечивает более плавное взаимодействие, минимизируя его вовлечённость в управление временем повтора запросов.

**Обработка изменённого запроса**

В ходе обработки необходимо сопоставлять запросы, где ключ служит лишь одним из критериев. Мы должны сравнить текущий запрос с тем, который уже был исполнен с этим ключом. Это необходимо для предотвращения потенциальных угроз безопасности сервиса. Блок контроля идемпотентности нацелен на полное исключение возможности возврата сохранённого ответа на изменённый запрос, опираясь исключительно на совпадение ключа идемпотентности. В случае выявления несовпадений между запросами система немедленно выдаёт ошибку с кодом 400 Bad Request. Это обеспечивает защиту от подобных сценариев. Блок контроля идемпотентности должен обеспечивать высокую степень настройки при сравнении запросов, обеспечивая максимальную гибкость в реализации API. При сопоставлении необходимо обязательно учитывать соответствие HTTP-метода и URI-путей. Можно добавить дополнительные варианты проверок, такие как:
1) Возможность учитывать содержимое тела запроса при определении идентичности запросов
2) Учёт различий в заголовках запросов для дополнительной точности идемпотентного сравнения
3) Сравнение параметров запросов
4) Учёт временных меток запросов для предотвращения возможных конфликтов