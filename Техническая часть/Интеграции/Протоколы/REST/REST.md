**REST** - стиль архитектурного взаимодействия. Чаще всего применяется для построения микросервисной архитектуры.

**Принципы REST:**
1) **Отделение интерфейса от реализации.** Клиенты взаимодействуют с сервисом через унифицированный интерфейс, не зная деталей его реализации
2) **Отстутствие состояния (Statelessness).** Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для его обработки; сервер не хранит состояние между запросами
3) **Кэширование.** Ответы сервера могут быть помечены как кэшируемые или некэшируемые, что позволяет клиентам сохранять и повторно использовать данные, снижая нагрузку на сеть
4) **Многоуровневая система (Layered System).** Архитектура может быть разделена на иерархические слои, где каждый слой выполняет свою функцию, не зная деталей других слоёв
5) **Код по требованию (Code on Demand).** Сервер может передавать исполняемый код клиенту для расширения его функциональности (например, JavaScript), хотя этот принцип используется реже
6) **Унифицированный интерфейс (Uniform Interface).** Определяет единый способ взаимодействия между клиентом и сервером, включая идентификацию ресурсов, манипуляцию ими и использование гипермедиа
7) **Использование HTTP-методов.** Использование HTTP-методов для построения взаимодействий

**Плюсы REST:**
1) **Простота и универсальность:**
	1) **Читаемость.** Использует стандартные HTTP-методы (GET, POST, PUT, DELETE), что упрощает работу с API
	2) **Лёгкость в изучении.** Большинство разработчиков знакомы с основами HTTP, что снижает порог вхождения
	3) **Инструментарий.** Совместимость с многочисленными инструментами (Postman, Swagger, cURL)
2) **Отделение клиента и сервера:**
	1) Клиент и сервер могут использовать разные технологии и языки программирования
	2) Это облегчает параллельную разработку клиентских и серверных приложений
3) **Широкая поддержка стандартов:**
	1) Использует открытые и хорошо документированные протоколы, такие как HTTP
	2) Поддержка кэширования, которое снижает нагрузку на сервер
4) **Масштабируемость:**
	1) Простота горизонтального масштабирования благодаря статeless-принципу (каждый запрос содержит всю необходимую информацию)
	2) Удобное разбиение системы на микросервисы
5) **Гибкость:**
	1) Возможность взаимодействия с любыми клиентами (браузеры, мобильные приложения, IoT-устройства)
	2) Поддержка различных форматов данных ([[JSON]], [[XML]], [[YAML]], [[Protobuf]])

**Минусы REST:**
1) **Низкая эффективность для сложных операций:**
	1) Отсутствие поддержки транзакций “из коробки” затрудняет реализацию сложных взаимодействий между микросервисами
	2) Множество запросов могут быть необходимы для выполнения одной операции (например, сбор информации из нескольких ресурсов)
2) **Высокая нагрузка на сеть:**
	1) REST использует текстовые форматы данных (чаще всего [[JSON]]), которые занимают больше места, чем бинарные форматы (например, [[Protobuf]])
	2) Каждый запрос требует передачи всех метаданных, что увеличивает объём передаваемых данных
3) **Ограничения статуса HTTP:**
	1) HTTP-методы и коды состояния могут быть недостаточно гибкими для описания сложных бизнес-процессов
	2) Ограничения REST могут привести к перегруженности некоторых методов (например, POST часто используется для операций, не соответствующих его изначальному предназначению)
4) **Отсутствие стандартизированных соглашений:**
	1) REST не навязывает строгие стандарты проектирования API, что приводит к разнородности API у разных разработчиков
	2) Может потребоваться больше времени на изучение специфики конкретного API
5) **Проблемы со сложной логикой:**
	1) REST не поддерживает встроенные механизмы событийной обработки и требует дополнительной настройки для работы с асинхронными операциями (например, через очереди сообщений)
	2) Для сложной логики, распределённых транзакций и согласованности лучше подойдут другие подходы, например, [[gRPC]] или [[GraphQL]]

**Уровни зрелости REST:**
1) **Уровень 0.** Сервисы имеют единственный URI, который использует единственный http-метод (как правило, метод POST). Примерами таких сервисов могут служить большинство веб-сервисов - они используют единственный URI для идентификации точки входа и HTTP POST для передачи SOAP-пакета с данными
2) **Уровень 1 (Resources(Ресурсы)).** Такие сервисы используют несклько URI, но единственный http-метод. Разница между L1 и L0, заключается в том, что L1 выставляет много логических ресурсов, а сервис уровня L0 объединяет все взаимодействия через единственный (большой и сложный) ресурс. В сервисах уровня L1, имена операций и параметров находятся в самом URI и передаются удалённому сервису, как правило через HTTP GET
3) **Уровень 2 (HTTP-verbs(http-методы/глаголы)).** Сервивсы этого уровня имеют много URI-адресуемых ресурсов и используют несколько http-методов для каждого ресурса. Это, как правило CRUD(Create Read Update Delete)-сервисы, где состояние ресурса представляет бизнес-сущность, которой можно управлять через сеть
4) **Уровень 3 (Hypermedia Controls).** Смысл таких сервисов в том, что при вызове сервиса, они возвращают не только состояние(изменённое или неизменённое), но и ссылки(слоты) на то что мы можем делать дальше с этим сервисом. Фактически, сервисы этого уровня пытаются обеспечить этакую само-документацию, т.е. дать пользователю возможность выбрать дальнейшие действия из доступного списка