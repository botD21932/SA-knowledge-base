**Оконная функция в SQL** - функция, которая работает с выделенным набором строк (окном, партицией) и выполняет вычисление для этого набора строк в отдельном столбце ([[Реляционные БД]]).

**Партиции (окна из набора строк)** - это набор строк, указанный для оконной функции по одному из столбцов или группе столбцов таблицы. Партиции для каждой оконной функции в запросе могут быть разделены по различным колонкам таблицы.
![[3e5dd68c86651bdd7774dd6b15fb5288.png]]

**В чем заключается главное отличие оконных функций от функций агрегации с группировкой?** 

При использовании агрегирующих функций предложение GROUP BY сокращает количество строк в запросе с помощью их группировки.
![[90a39588318aad8a733e87647d797af1.png]]
При использовании оконных функций количество строк в запросе не уменьшается по сравнении с исходной таблицей.
![[696a8dcb16b5c8e4499961dab2b8f19a.png]]

**Порядок расчета оконных функций в SQL запросе**

![[3c5829ff6fdce67e967d07515eee3bc5.png]]
Сначала выполняется команда выборки таблиц, их объединения и возможные подзапросы под командой FROM. Далее выполняются условия фильтрации WHERE, группировки GROUP BY и возможная фильтрация c HAVING Только потом применяется команда выборки столбцов SELECT и расчет оконных функций под выборкой.  После этого идет условие сортировки ORDER BY, где тоже можно указать столбец расчета оконной функции для сортировки.  Здесь важно уточнить, что партиции или окна оконных функций создаются после разделения таблицы на группы с помощью команды GROUP BY, если эта команда используется в запросе.

**Синтаксис оконных функций**

![[69b77ca8275ff1a615bcacdd5607fb1a.png]]
Оконные функции можно прописывать как под командой SELECT, так и в отдельном ключевом слове WINDOW, где окну дается алиас (псевдоним), к которому можно обращаться в SELECT выборке.

**Классы оконных функций:**
1) **Агрегирующие (Aggregate).** Можно применять любую из агрегирующих функций - SUM, AVG, COUNT, MIN, MAX
2) **Ранжирующие (Ranking).** В ранжирующих функция под ключевым словом OVER обязательным идет указание условия ORDER BY, по которому будет происходить сортировка ранжирования:
	1) **ROW_NUMBER().** Функция вычисляет последовательность ранг (порядковый номер) строк внутри партиции, НЕЗАВИСИМО от того, есть ли в строках повторяющиеся значения или нет
	2) **RANK().** Функция вычисляет ранг каждой строки внутри партиции. Если есть повторяющиеся значения, функция возвращает одинаковый ранг для таких строчек, пропуская при этом следующий числовой ранг
	3) **DENSE_RANK().** То же самое что и RANK, только в случае одинаковых значений DENSE_RANK не пропускает следующий числовой ранг, а идет последовательно
3) **Функции смещения (Value).** Это функции, которые позволяют перемещаясь по выделенной партиции таблицы обращаться к предыдущему значению строки или крайним значениям строк в партиции:
	1) **LAG().** Функция, возвращающая предыдущее значение столбца по порядку сортировки
	2) **LEAD().** Функция, возвращающая следующее значение столбца по порядку сортировки
	3) **FIRST_VALUE()/LAST_VALUE().** Функции возвращающие первое или последнее значение столбца в указанной партиции. В качестве аргумента указывает столбец, значение которого нужно вернуть. В оконной функции под словом OVER обязательное указание ORDER BY условия

**Фрейм** - это набор строк, с которыми **в данный момент работает оконная функция** внутри окна. Это механизм, который позволяет определить границы набора строк в рамках каждой группы данных, на которых должны выполняться вычисления оконных функций. Фреймы используются когда оконная функция должна динамически менять набор строк для расчета, а не производить расчет только для статичного набора строк в окне.

**Синтаксис оконных функций с фреймом выглядит следующим образом:** название_оконной_функции OVER (описание_окна  описание_фрейма)

На картинке ниже вы увидите синтаксис со всеми SQL командами для создания оконки с фреймом:
![[896afc1776443a4d7eb8704f37f2d190.png]]

**Описание фрейма состоит из следующего синтаксиса:** тип_фрейма BETWEEN начальная_граница_фрейма AND конечная_граница_фрейма

**Границы фреймов**

Границы фреймов определяют тот самый динамический диапазон строк, в котором будет работать оконная функция. Для понимания нам важно усвоить следующую вещь - есть верхняя и нижняя граница, они в свою очередь зависят от текущей строки (current row), в которой работает оконная функция.
![[aaa831306a25c8a59ee14137e481d149.png]]
**Примеры:**
1) **ROWS BETWEEN 4 PRECEDING AND 2 FOLLOWING.** Фрейм включает в себя 4 записи до текущей строки, текущую строку и 2 записи после текущей строки![[47adedf9391548c20acfa1008cc93463.png]]
2) **ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.** Фрейм с границей от начала окна до текущей строки![[6bd86f03ec5bd071ddfda15c379d9ad6.png]]

**Виды фреймов:**
1) **ROWS.** Задаёт фреймы по строкам и включает в себя определенное количество строк от начала до конца окна
2) **RANGE.** Включает в себя значения в определенном диапазоне значений столбца сортировки от текущей строки до границ фрейма
3) **GROUPS.** Включает в себя все строки с одинаковым значением столбца сортировки

**Правила применения фреймов оконных функций:**
1) Не для всех оконных функций существуют фреймы. Фреймы можно применять с функциями агрегации (со всеми) и с некоторыми функциям смещения (first_value, last_value), а вот для ранжирующих функций фреймов нет и логически их даже представить в применении нельзя
2) Если задано окно (PARTITION BY), то фрейм будет работать внутри каждого окна отдельно
3) Для фреймов по логике задач важна сортировка данных внутри окна (ORDER BY). Без явной сортировки данных вы можете получить неинформативный и неправильный результат расчетов